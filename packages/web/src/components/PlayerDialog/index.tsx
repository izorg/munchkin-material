import { mdiGenderFemale, mdiGenderMale } from "@mdi/js";
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  FormControl,
  FormControlLabel,
  FormLabel,
  Grid,
  InputLabel,
  OutlinedInput,
  Radio,
  RadioGroup,
  SvgIcon,
  Typography,
} from "@mui/material";
import { type FormEvent, useEffect, useMemo, useRef } from "react";
import { useIntl } from "react-intl";
import { useSearchParams } from "react-router";

import { type Player, Sex } from "../../domains/player";
import { addPlayerToList } from "../../ducks/playerList";
import { addPlayer, updatePlayer } from "../../ducks/players";
import useDeletePlayers from "../../hooks/useDeletePlayers";
import usePresentSelector from "../../hooks/usePresentSelector";
import { useAppDispatch } from "../../store";
import { type AvailableColor } from "../../utils/availableColors";
import createPlayer from "../../utils/createPlayer";
import getRandomMaterialColor from "../../utils/getRandomMaterialColor";
import { useGoBack } from "../../utils/location";
import shallowEqual from "../../utils/shallowEqual";
import CancelButton from "../CancelButton";
import SubmitButton from "../SubmitButton";

import AppBar from "./AppBar";
import ColorPicker from "./ColorPicker";
import formId from "./formId";
import { PlayerDialogTransition } from "./PlayerDialogTransition";
import { useFullScreen } from "./useFullScreen";

const PlayerDialog = () => {
  const dispatch = useAppDispatch();
  const intl = useIntl();

  const deletePlayers = useDeletePlayers();
  const goBack = useGoBack();
  const [searchParams] = useSearchParams();
  const open = searchParams.get("player") !== null;
  const players = usePresentSelector((state) => state.players);

  const queryPlayer = searchParams.get("player");

  const previousPlayerRef = useRef(
    queryPlayer ? players[queryPlayer] : undefined,
  );

  const editPlayer = useMemo(() => {
    if (open) {
      return queryPlayer ? players[queryPlayer] : undefined;
    }

    return previousPlayerRef.current;
  }, [open, players, queryPlayer]);

  useEffect(() => {
    if (open) {
      previousPlayerRef.current = queryPlayer
        ? players[queryPlayer]
        : undefined;
    }
  }, [open, players, queryPlayer]);

  const randomColor = useMemo(
    () =>
      getRandomMaterialColor(
        Object.values(players)
          .map((player) => player.color)
          .filter((color): color is AvailableColor => color !== undefined),
      ),
    [players],
  );

  const fullScreen = useFullScreen();

  const handleDelete = editPlayer
    ? async () => {
        deletePlayers([editPlayer.id]);
        await goBack();
      }
    : undefined;

  const onSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const formData = new FormData(event.target as HTMLFormElement);

    const formValues: Partial<Player> = Object.fromEntries(formData);

    if (!formValues.name?.trim()) {
      await goBack();

      return;
    }

    if (editPlayer) {
      const player: Player = {
        ...editPlayer,
        ...formValues,
      };

      if (shallowEqual(editPlayer, player)) {
        await goBack();

        return;
      }

      dispatch(updatePlayer(player));
    } else {
      const player = createPlayer(formValues);

      dispatch(addPlayer(player));
      dispatch(addPlayerToList(player.id));
    }

    await goBack();
  };

  const title = editPlayer
    ? // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
      intl.formatMessage({
        defaultMessage: "Edit munchkin",
        id: "player.form.titleEdit",
      })
    : // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
      intl.formatMessage({
        defaultMessage: "New munchkin",
        id: "player.form.title",
      });

  // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
  const nameLabel = intl.formatMessage({
    defaultMessage: "Name",
    id: "player.form.namePlaceholder",
  });

  const nameId = "player-form-name";

  return (
    <Dialog
      disableRestoreFocus
      fullScreen={fullScreen}
      hideBackdrop={fullScreen}
      onClose={goBack}
      open={open}
      slotProps={{
        paper: {
          elevation: fullScreen ? 0 : 1,
          sx: {
            minWidth: {
              lg: "320px",
            },
          },
        },
      }}
      slots={{ transition: PlayerDialogTransition }}
      sx={{
        height: "inherit", // scrolling body in cordova for small screen height
      }}
    >
      <DialogTitle
        sx={(theme) => ({
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",

          [theme.breakpoints.down("lg")]: {
            display: "block",
            padding: 0,
          },
        })}
      >
        {fullScreen ? (
          <AppBar onCancel={goBack} onDelete={handleDelete} title={title} />
        ) : (
          <Typography component="span" noWrap variant="h6">
            {title}
          </Typography>
        )}
      </DialogTitle>
      <DialogContent
        sx={[
          (theme) => ({
            paddingLeft: "calc(24px + var(--inset-left)) /*! @noflip */",
            paddingRight: "calc(24px + var(--inset-right)) /*! @noflip */",

            [theme.breakpoints.up("md")]: {
              alignSelf: "center",
              width: "600px",
            },
          }),
          fullScreen && {
            paddingBottom: "calc(20px + var(--keyboard-height))",
          },
        ]}
      >
        <form id={formId} onSubmit={onSubmit}>
          <FormControl fullWidth margin="normal">
            <InputLabel htmlFor={nameId}>{nameLabel}</InputLabel>
            <OutlinedInput
              autoFocus={!editPlayer}
              defaultValue={editPlayer?.name}
              id={nameId}
              label={nameLabel}
              name="name"
            />
          </FormControl>

          <Grid container>
            <Grid size={6}>
              <FormControl component="fieldset" margin="normal">
                <FormLabel component="legend">
                  {
                    // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
                    intl.formatMessage({
                      defaultMessage: "Sex",
                      id: "player.form.sex",
                    })
                  }
                </FormLabel>
                <RadioGroup
                  defaultValue={editPlayer?.sex ?? Sex.Male}
                  name="sex"
                >
                  <FormControlLabel
                    control={<Radio color="primary" />}
                    label={
                      <SvgIcon sx={{ verticalAlign: "middle" }}>
                        <path d={mdiGenderMale} />
                      </SvgIcon>
                    }
                    value={Sex.Male}
                  />
                  <FormControlLabel
                    control={<Radio color="primary" />}
                    label={
                      <SvgIcon sx={{ verticalAlign: "middle" }}>
                        <path d={mdiGenderFemale} />
                      </SvgIcon>
                    }
                    value={Sex.Female}
                  />
                </RadioGroup>
              </FormControl>
            </Grid>

            <Grid size={6}>
              <FormControl margin="normal">
                <FormLabel>
                  {
                    // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
                    intl.formatMessage({
                      defaultMessage: "Color",
                      id: "player.form.color",
                    })
                  }
                </FormLabel>
                <ColorPicker
                  defaultValue={editPlayer?.color ?? randomColor}
                  name="color"
                />
              </FormControl>
            </Grid>
          </Grid>
        </form>
      </DialogContent>
      {!fullScreen && (
        <DialogActions>
          {editPlayer && (
            <Button onClick={handleDelete} sx={{ marginRight: "auto" }}>
              {
                // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
                intl.formatMessage({
                  defaultMessage: "Delete",
                  id: "player.form.delete",
                })
              }
            </Button>
          )}
          <CancelButton onClick={goBack} />
          <SubmitButton form={formId}>
            {
              // eslint-disable-next-line formatjs/enforce-id -- will migrate to autogenerated ids
              intl.formatMessage({
                defaultMessage: "Save",
                id: "player.form.save",
              })
            }
          </SubmitButton>
        </DialogActions>
      )}
    </Dialog>
  );
};

export default PlayerDialog;
